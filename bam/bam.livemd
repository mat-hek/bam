# BamBam

```elixir
Logger.configure(level: :info)

Mix.install([
  :evision,
  :membrane_sdk,
  {:membrane_webrtc_plugin, "~> 0.19.0"},
  {:ex_sdp, "~> 0.15.0", override: true},
  :kino
])
```

## Setup

```elixir
Evision.getBuildInformation() |> IO.puts()
```

```elixir
defmodule SilenceFiller do
  use Membrane.Filter

  def_input_pad(:input, accepted_format: Membrane.RawAudio)
  def_output_pad(:output, accepted_format: Membrane.RawAudio)

  @time Membrane.Time.milliseconds(20)

  @impl true
  def handle_stream_format(:input, _format, ctx, state) when ctx.old_stream_format != nil do
    {[], state}
  end

  @impl true
  def handle_stream_format(:input, format, _ctx, _opts) do
    {[stream_format: {:output, format}, start_timer: {:timer, @time}], %{overtime: 0, pts: 0}}
  end

  @impl true
  def handle_tick(:timer, ctx, state) do
    %{overtime: overtime, pts: pts} = state
    time = @time - overtime

    if time > 0 do
      silence = Membrane.RawAudio.silence(ctx.pads.input.stream_format, time)
      buffer = %Membrane.Buffer{payload: silence, pts: state.pts}

      real_time =
        Membrane.RawAudio.bytes_to_time(byte_size(buffer.payload), ctx.pads.input.stream_format)

      {[buffer: {:output, buffer}], %{state | pts: pts + real_time, overtime: 0}}
    else
      {[], %{state | overtime: overtime - @time}}
    end
  end

  @impl true
  def handle_buffer(:input, buffer, ctx, state) do
    duration =
      Membrane.RawAudio.bytes_to_time(byte_size(buffer.payload), ctx.pads.input.stream_format)

    actions = [buffer: {:output, %{buffer | pts: state.pts}}]
    state = %{state | overtime: state.overtime + duration, pts: state.pts + duration}
    {actions, state}
  end
end
```

<!-- livebook:{"branch_parent_index":0} -->

## Get media

```elixir
import Membrane.ChildrenSpec

p = Membrane.RCPipeline.start_link!()

Membrane.RCPipeline.exec_actions(p,
  spec:
    child(Membrane.CameraCapture)
    |> child(%Membrane.FFmpeg.SWScale.PixelFormatConverter{format: :I420})
    |> child(Membrane.SDL.Player)
)
```

```elixir
Membrane.Pipeline.terminate(p)
```

## Detect hand movement

```elixir
path = "#{__DIR__}/../models"

network =
  Evision.DNN.readNetFromDarknet("#{path}/cross-hands.cfg",
    darknetModel: "#{path}/cross-hands.weights"
  )

Evision.DNN.Net.setPreferableTarget(network, Evision.Constant.cv_DNN_TARGET_OPENCL())
Evision.DNN.Net.setPreferableBackend(network, Evision.Constant.cv_DNN_BACKEND_OPENCV())
output_layers = Evision.DNN.Net.getUnconnectedOutLayersNames(network)

model = %{network: network, output_layers: output_layers, input_size: {416, 416}}
```

```elixir
defmodule BamBam do
  use Membrane.Filter

  def_input_pad(:input, accepted_format: Membrane.RawVideo)
  def_output_pad(:output, accepted_format: Membrane.RawAudio)

  @bam %Membrane.Buffer{payload: File.read!("#{__DIR__}/bam.pcm")}
  @clap %Membrane.Buffer{payload: File.read!("#{__DIR__}/clap.pcm")}

  def_options(model: [])

  @impl true
  def handle_init(_ctx, opts) do
    frame = Kino.Frame.new()
    Kino.render(frame)
    {[], %{processing: false, frame: frame, model: opts.model, min_y: 1}}
  end

  @impl true
  def handle_stream_format(:input, _format, _ctx, state) do
    stream_format = %Membrane.RawAudio{sample_rate: 48_000, channels: 2, sample_format: :s16le}
    {[stream_format: {:output, stream_format}], state}
  end

  @impl true
  def handle_buffer(:input, %{payload: payload}, ctx, state) do
    element = self()

    unless state.processing do
      Task.start_link(fn ->
        inference = infer(payload, ctx.pads.input.stream_format, state.model)
        send(element, {:inference, inference})
      end)
    end

    {[], %{state | processing: true}}
  end

  @impl true
  def handle_info({:inference, %{x: x, y: y, score: score}}, _ctx, state) do
    state = %{state | processing: false}

    if score >= 0.5, do: Kino.Frame.render(state.frame, {x, y})

    cond do
      score < 0.5 ->
        {[], state}

      y < state.min_y ->
        {[], %{state | min_y: y}}

      y - state.min_y > 0.1 ->
        buffer =
          if x < 0.5 do
            IO.write("CLAP ")
            @clap
          else
            IO.write("BAM ")
            @bam
          end

        {[buffer: {:output, buffer}], %{state | min_y: 1}}

      true ->
        {[], state}
    end
  end

  defp infer(payload, %{width: width, height: height}, model) do
    %{network: network, output_layers: output_layers, input_size: input_size} = model

    img = Evision.Mat.from_binary(payload, {:u, 8}, height, width, 3)

    blob =
      Evision.DNN.blobFromImage(img, scalefactor: 1.0 / 255.0, size: input_size)

    Evision.DNN.Net.setInput(network, blob)
    outputs = Evision.DNN.Net.forwardAndRetrieve(network, output_layers)

    outputs
    |> List.flatten()
    |> Enum.map(&Evision.Mat.to_nx/1)
    |> Enum.flat_map(&Nx.to_list/1)
    |> Enum.map(fn [x, y, _w, h | scores] ->
      %{x: x - h / 2, y: y, score: Enum.max(scores)}
    end)
    |> Enum.max_by(& &1.score)
  end
end
```

<!-- livebook:{"branch_parent_index":2} -->

## BamBam

```elixir
import Membrane.ChildrenSpec

p = Membrane.RCPipeline.start_link!()

Membrane.RCPipeline.exec_actions(p,
  spec:
    child(Membrane.CameraCapture)
    |> child(%Membrane.FFmpeg.SWScale.PixelFormatConverter{format: :RGB})
    |> child(%BamBam{model: model})
    |> child(Membrane.PortAudio.Sink)
)
```

```elixir
Membrane.RCPipeline.terminate(p)
```

<!-- livebook:{"branch_parent_index":2} -->

## WebRTC

```elixir
ip = {192, 168, 83, 200}
```

```elixir
import Membrane.ChildrenSpec

p = Membrane.RCPipeline.start_link!()

Membrane.RCPipeline.exec_actions(p,
  spec:
    child(%Membrane.WebRTC.Source{
      signaling: {:websocket, ip: ip, port: 8829},
      video_codec: :h264
    })
    |> via_out(:output, options: [kind: :video])
    |> child(Membrane.H264.Parser)
    |> child(Membrane.H264.FFmpeg.Decoder)
    |> child(%Membrane.FFmpeg.SWScale.PixelFormatConverter{format: :RGB})
    |> child(%BamBam{model: model})
    |> child(SilenceFiller)
    |> child(Membrane.Opus.Encoder)
    |> via_in(:input, options: [kind: :audio])
    |> child(%Membrane.WebRTC.Sink{signaling: {:websocket, ip: ip, port: 8830}})
)
```

```elixir
Membrane.RCPipeline.terminate(p)
```
