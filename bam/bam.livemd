# BamBam

```elixir
Logger.configure(level: :info)

Mix.install([:evision, :membrane_sdk, :kino])
```

## Section

```elixir
Evision.getBuildInformation() |> IO.puts()
```

```elixir
import Membrane.ChildrenSpec

{:ok, _sup, p} = Kino.start_child(Membrane.RCPipeline)

defmodule Intercept do
  use Membrane.Filter
  def_input_pad(:input, accepted_format: _any)
  def_output_pad(:output, accepted_format: _any)

  @impl true
  def handle_stream_format(:input, format, _ctx, state) do
    format = %{format | pixel_format: :NV12}
    {[forward: format], state}
  end

  @impl true
  def handle_buffer(:input, buffer, _ctx, state) do
    {[buffer: {:output, buffer}], state}
  end
end

frame = Kino.Frame.new()

Membrane.RCPipeline.exec_actions(p,
  spec:
    child(Membrane.CameraCapture)
    # |> child(Intercept)
    |> child(%Membrane.FFmpeg.SWScale.PixelFormatConverter{format: :RGB})
    |> child(%BamBam{frame: frame})
    |> child(Membrane.PortAudio.Sink)

  # |> child(Membrane.SDL.Player)
)

frame
```

```elixir
Membrane.RCPipeline.terminate(p, force?: true)
```

```elixir
defmodule BamBam do
  use Membrane.Filter

  def_input_pad(:input, accepted_format: Membrane.RawVideo)
  def_output_pad(:output, accepted_format: Membrane.RawAudio)

  def_options(frame: [])

  @impl true
  def handle_setup(_ctx, opts) do
    <<_pre_bam::binary-size(2000 * 4), bam::binary-size(10_000 * 4), _rest::binary>> =
      File.read!("#{__DIR__}/bam.pcm")

    bam = %Membrane.Buffer{payload: bam}

    path = "#{__DIR__}/../models"

    net =
      Evision.DNN.readNetFromDarknet("#{path}/cross-hands.cfg",
        darknetModel: "#{path}/cross-hands.weights"
      )

    Evision.DNN.Net.setPreferableTarget(net, Evision.Constant.cv_DNN_TARGET_OPENCL())
    Evision.DNN.Net.setPreferableBackend(net, Evision.Constant.cv_DNN_BACKEND_OPENCV())

    {[], %{task: nil, frame: opts.frame, net: net, up_time: nil, bam: bam}}
  end

  @impl true
  def handle_stream_format(:input, _format, _ctx, state) do
    stream_format = %Membrane.RawAudio{sample_rate: 44100, channels: 2, sample_format: :s16le}
    {[stream_format: {:output, stream_format}], state}
  end

  @impl true
  def handle_buffer(:input, %{payload: payload}, ctx, state) do
    if state.task && Process.alive?(state.task) do
      {[], state}
    else
      element = self()

      {:ok, task} =
        Task.start_link(fn ->
          with {x, y} <- infer(payload, ctx.pads.input.stream_format, state) do
            send(element, {:inference, x, y})
          end
        end)

      {[], %{state | task: task}}
    end
  end

  @impl true
  def handle_info({:inference, _x, y}, _ctx, state) do
    cond do
      y < 0.5 ->
        {[], %{state | up_time: Membrane.Time.monotonic_time()}}

      y > 0.6 and state.up_time ->
        if Membrane.Time.monotonic_time() - state.up_time < Membrane.Time.second(),
          do: IO.write("BAM ")

        {[buffer: {:output, state.bam}], %{state | up_time: nil}}

      true ->
        {[], state}
    end
  end

  defp infer(payload, %{width: width, height: height}, state) do
    img = Evision.Mat.from_binary(payload, {:u, 8}, height, width, 3)
    input_size = 416

    blob =
      Evision.DNN.blobFromImage(
        img,
        scalefactor: 1.0 / 255.0,
        size: {input_size, input_size},
        swapRB: false,
        crop: false
      )

    out_layer_names = Evision.DNN.Net.getUnconnectedOutLayersNames(state.net)

    Evision.DNN.Net.setInput(state.net, blob)
    outputs = Evision.DNN.Net.forwardAndRetrieve(state.net, out_layer_names)

    output =
      outputs
      |> List.flatten()
      |> Enum.map(&Evision.Mat.to_nx/1)
      |> Enum.flat_map(&Nx.to_list/1)
      |> Enum.map(fn [x, y, _w, _h | scores] ->
        %{x: x, y: y, score: Enum.max(scores)}
      end)
      |> Enum.sort_by(& &1.score, :desc)
      |> hd()

    if output.score > 0.5 do
      {output.x, output.y}
      |> tap(&Kino.Frame.render(state.frame, &1))
    end

    # if output.score > 0.5 do
    #   Evision.circle(img, {trunc(output.x * width), trunc(output.y * height)}, 100, {255},
    #     thickness: -1
    #   )
    # else
    #   Evision.circle(img, {0, 0}, 100, {255}, thickness: -1)
    # end
    # |> Evision.cvtColor(Evision.Constant.cv_COLOR_RGB2BGR())
    # |> then(&Kino.Frame.render(state.frame, &1))
  end
end
```
